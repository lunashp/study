## SSR (Server Side Rendering)

- 인덱스 페이지에 표시되어야 할 html 파일을 먼저 브라우저가 다운 -> javascript 파일 다운
- javascript 파일을 다운 받는 동안에 이미 html 파일의 렌더링을 시작하기 때문에 웹페이지 표시가 빠름
- 컴퓨터의 속도가 느리다면 처음에 javascript가 다 다운이 받아지지 않아서 기능이 동작하지 않을 수도 있음
- 사용자가 네비게이션의 링크를 클릭하여 페이지를 이동했을 때 해당 페이지의 html 파일을 다운 받고 이어서 javascript 파일을 다운 받는 일련의 과정이 반복
  - 그래서 렌더링이 빠른 장점이 있지만 페이지를 이동할 때마다 화면 깜박임(화면이 로드될 때마다 화면이 백지로 변하고 다시 화면이 출력되는 과정)이 있음
  - 웹페이지의 용량이 가벼울 경우에는 문제가 없으나 무거워질 경우에는 화면 깜박임이 길어져 사용자 경험이 나빠질 수 있음

## CSR

맨 처음 url 요청에 웹문서가 가지고 있는 모든 정보, 링크페이지까지도 한번에 다 받아옴

- 초기 화면 로드가 느림
  - 일단 로드가 되고 나면 사이트 내에서 돌아다닐 때 로드되는 과정이 없어지므로 사용성이 좋아짐
- 우리가 흔히 쓰는 페이스북과 같은 대형 플랫폼들의 화면이 많은 사진과 정보가 있음에도 페이지를 이동할 때 화면 깜박임이 없는 이유는 바로 이 때문임
- 보통 로드가 될 때 ‘Loading’임을 표시해주는 화면이 먼저 표시되도록 만듦
- CSR 방식은 보통 링크 이동을 할 때 자바스크립트를 이용해 동적으로 화면을 바꿔주므로, html 문서가 가지고 있는 정보가 적어서 검색엔진들이 웹사이트를 분석해서 내용들을 파악하고 검색 시에 뿌려주어야 할 때 제대로 걸러지지 못 하게 됨
- 이를 SEO(검색엔진최적화)가 나쁘다고 말함

# Next.js

```
개발환경 실행   $ npm run dev
배포 파일 생성  $ npm run build
서비스 시작     $ npm run start
```

# react

## 컴포넌트

- 화면을 이루는 '요소'로 여러 곳에서 재사용 가능한 UI 코드 조각
- 개발하다가 특정 부분에서 버그가 일어난다면 그 컴포넌트만 수정하여 사용할 수 있음
  - 코드의 재사용성과 유지보수성 증가
- react 데이터의 흐름은 `단방향` 으로 이루어짐
  - 부모에서 자식으로 한 방향으로만 데이터를 props를 사용하여 공유해줄 수 있음

### props

- property의 줄임말
- 부모 컴포넌트 -> 자식 컴포넌트로 데이터를 전달해주는 개념
- 자식 컴포넌트에서 전달 받은 props는 읽기 전용이고 props를 전달해준 최상위 부모 컴포넌트만 props 변경 가능

### state

- 컴포넌트의 상태를 나타내고 동적인 데이터를 다룰 때 사용함
- useState 함수로 상태를 추가할 수 있음
- `const [상태명, 상태변경 함수명] = useState(초기값);`

#### 제어 컴포넌트

- 사용자가 제어 컴포넌트에 데이터를 입력하면 변경 이벤트 핸들러가 호출되고 코드가 업데이트 된 값으로 다시 렌더링이 됨
- 대표적으로 form에 `value`값을 `useState`로 관리해서 데이터를 최신화 하는 것
- 텍스트 입력을 할 때마다 onChange의 콜백 호출에 따라서 form의 상태가 계속 즉각적으로 렌더링 되는 것을 제어컴포넌트 라고 함

```
const [inputValue, setInputValue] = useState('');

return (
    <input value={inputValue} onChange{(e) => setInputValue(e.target.value)}/>
)
```

- ex)
  - form의 유효성 검사할 때 (아이디나 비밀번호 체크 시)
  - form에 데이터 값에 따라 버튼 상태를 disabled로 표시

#### 비제어 컴포넌트

- 사용자가 폼 필드에 대이터를 입력하면 업데이트된 정보가 리엑트에서 별도 처리할 필요 없이 엘리먼트에 반영
- 제어 컴포넌트는 useState로 관리하지만 비제어 컴포넌트는 ref로 관리
- ref를 활용해 입력폼의 상태를 접근 가능
  - button을 클릭할 때 ref를 통해 값을 얻을 수 있음

```
const inputRef = useRef();
return {
    <input ref={inputRef} value="hello" />
}
```

- ex)
  - 불필요한 렌더링을 줄이고, 버튼을 클릭하여 제출할 때 값이 필요한 경우 사용

## hooks

### useState

- 컴포넌트의 상태를 관리할 수 있음
- 상태에 따라 즉각적으로 다른 화면들을 출력해줌 (=랜더링)

### useEffect

- 랜더링 이후에 실행할 코드를 만들어줌
- 사이드 이팩트를 감지하는 함수, 감시대상이 변하면 콜백을 실행함

```
useEffect(감시대상이 변하면 동작할 콜백, [감시대상])
```

- 언마운트 될 때만 cleanUp 함수를 실행시키고 싶으면 deps에 빈 배열을 넣으면 됨
- 특정 값이 업데이트 되기 직전에 cleanUp 합수를 실행시키고 싶다면 deps에 해당 값을 넣어주면 됨

```
useEffect(() => {
    console.log("hello");
    return () => {
        console.log("cleanUp 함수");
    };
});
```

- 유의 사항
  - useEffect는 첫 렌더링 후 실행
  - 최초 한 번은 무조건 실행됨

### useRef

- 컴포넌트나 HTML의 DOM요소를 ref로 관리할 수 있음

### useMemo & useCallback

- 의존성 배열에 적힌 값이 변할 때만 값, 함수를 다시 정의할 수 있음
- 주로 렌더링 성능을 최적화 해야 하는 상황에 사용
- 렌더링마다 새롭게 함수가 추가되는 것을 방지하고 감시 대상이 변하지 않는 이상 함수를 새롭게 생성하지 않음

```
useCallback(콜백, [의존성])

// 렌더링마다 매번 새롭게 생성
const foo = () => {}

// 매번 새롭게 생성 되지 않음
const foo2 = useCallback(() => {}, [])

// a 값이 바뀌지 않는 이상 매번 새롭게 생성 되지 않음
const foo3 = useCallback(() => {}, [a])
```
